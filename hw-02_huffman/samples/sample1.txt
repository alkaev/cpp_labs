'''Алгоритм Хаффмана''' — [[Жадный алгоритм|жадный алгоритм]] оптимального [[префиксный код|префиксного]] [[энтропийное кодирование|кодирования]] алфавита с минимальной [[избыточность]]ю. Был разработан в [[1952 год]]у аспирантом [[Массачусетский технологический институт|Массачусетского технологического института]] [[Хаффман, Дэвид|Дэвидом Хаффманом]] при написании им курсовой работы<ref>{{Cite journal | last1 = Huffman | first1 = D. | author-link1 = David A. Huffman | title = A Method for the Construction of Minimum-Redundancy Codes | doi = 10.1109/JRPROC.1952.273898 | journal = [[Proceedings of the IRE]] | volume = 40 | issue = 9 | pages = 1098–1101 | year = 1952 | url = http://compression.ru/download/articles/huff/huffman_1952_minimum-redundancy-codes.pdf | access-date = 2022-12-04 | archive-date = 2010-12-15 | archive-url = https://web.archive.org/web/20101215184132/http://compression.ru/download/articles/huff/huffman_1952_minimum-redundancy-codes.pdf | deadlink = no }}</ref>. В настоящее время используется во многих программах [[Сжатие данных|сжатия данных]].

В отличие от [[Алгоритм Шеннона — Фано|алгоритма Шеннона — Фано]], алгоритм Хаффмана остаётся всегда оптимальным и для [[вторичный алфавит|вторичных алфавитов]] m<sub>2</sub> с более чем двумя символами.

Этот метод кодирования состоит из двух основных этапов:
# Построение оптимального кодового дерева.
# Построение отображения код-символ на основе построенного дерева.

== Классический алгоритм Хаффмана ==
Идея алгоритма состоит в следующем: зная вероятности появления символов в сообщении, можно описать процедуру построения кодов переменной длины, состоящих из целого количества битов. Символам с большей вероятностью ставятся в соответствие более короткие коды. Коды Хаффмана обладают свойством [[Префиксный код|префиксности]] (то есть ни одно кодовое слово не является префиксом другого), что позволяет однозначно их декодировать.

Классический алгоритм Хаффмана на входе получает таблицу [[частотность|частотностей]] символов в сообщении. Далее на основании этой таблицы строится дерево кодирования Хаффмана (Н-дерево).<ref>Д. Мастрюков. [http://www.compression.ru/download/articles/huff/mastrukov_1993_huffman.pdf Монитор 7-8.93] {{Wayback|url=http://www.compression.ru/download/articles/huff/mastrukov_1993_huffman.pdf |date=20180517062535 }}</ref>
# Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
# Выбираются два свободных узла дерева с наименьшими весами.
# Создается их родитель с весом, равным их суммарному весу.
# Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.
# Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.
# Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.

Допустим, у нас есть следующая таблица абсолютных частотностей:
{| class="wikitable"
!Символ
!А
!Б
!В
!Г
!Д
|-
!Абсолютная частотность
| 15 || 7 || 6 || 6 || 5
|}

Этот процесс можно представить как построение [[Дерево (теория графов)|дерева]], корень которого — символ с суммой вероятностей объединенных символов, получившийся при объединении символов из последнего шага, его n<sub>0</sub> потомков — символы из предыдущего шага и т. д.

Чтобы определить код для каждого из символов, входящих в сообщение, мы должны пройти путь от листа дерева, соответствующего текущему символу, до его корня, накапливая биты при перемещении по ветвям дерева (первая ветвь в пути соответствует младшему биту). Полученная таким образом последовательность битов является кодом данного символа, записанным в обратном порядке.
[[Файл:Huffmantree ru animated.gif|thumb|300px|Построение дерева для данного примера]]
Для данной таблицы символов коды Хаффмана будут выглядеть следующим образом.
{| class="wikitable"
!Символ
! А || Б || В || Г || Д
|-
![[Префиксный код#генерация двоичного префиксного кода|Код{{якорь|префиксный_код}}]]
| 0 || 100 || 101 || 110 || 111
|}

Поскольку ни один из полученных кодов не является префиксом другого, они могут быть однозначно декодированы при чтении их из потока. Кроме того, наиболее частый символ сообщения А закодирован наименьшим количеством бит, а наиболее редкий символ Д — наибольшим.

При этом общая длина сообщения, состоящего из приведённых в таблице символов, составит 87 бит (в среднем 2,2308 бита на символ). При использовании равномерного кодирования общая длина сообщения составила бы 117 бит (ровно 3 бита на символ). Заметим, что [[Информационная энтропия|энтропия]] источника, независимым образом порождающего символы с указанными частотностями, составляет ~2,1858 бита на символ, то есть [[Избыточность информации|избыточность]] построенного для такого источника кода Хаффмана, понимаемая как отличие среднего числа бит на символ от энтропии, составляет менее 0,05 бита на символ.

Классический алгоритм Хаффмана имеет ряд существенных недостатков. Во-первых, для восстановления содержимого сжатого сообщения декодер должен знать таблицу частотностей, которой пользовался кодер. Следовательно, длина сжатого сообщения увеличивается на длину таблицы частотностей, которая должна посылаться впереди данных, что может свести на нет все усилия по сжатию сообщения. Кроме того, необходимость наличия полной частотной статистики перед началом собственно кодирования требует двух проходов по сообщению: одного для построения модели сообщения (таблицы частотностей и Н-дерева), другого - для собственно кодирования. Во-вторых, избыточность кодирования обращается в ноль лишь в тех случаях, когда вероятности кодируемых символов являются обратными степенями числа 2. В-третьих, для источника с энтропией, не превышающей 1 (например, для двоичного источника), непосредственное применение кода Хаффмана бессмысленно.

== Адаптивное сжатие ==
{{основная статья|Адаптивный алгоритм Хаффмана}}
Адаптивное сжатие позволяет не передавать модель сообщения вместе с ним самим и ограничиться одним проходом по сообщению как при кодировании, так и при декодировании.

В создании алгоритма адаптивного кодирования Хаффмана наибольшие сложности возникают при разработке процедуры обновления модели очередным символом. Теоретически можно было бы просто вставить внутрь этой процедуры полное построение дерева кодирования Хаффмана, однако, такой алгоритм сжатия имел бы неприемлемо низкое быстродействие, так как построение Н-дерева — это слишком большая работа, и производить её при обработке каждого символа неразумно. К счастью, существует способ модифицировать уже существующее Н-дерево так, чтобы отобразить обработку нового символа. Наиболее известными алгоритмами перестроения являются алгоритм Фоллера-Галлагера-Кнута (FGK) и алгоритм Виттера.

Все алгоритмы перестроения дерева при считывании очередного символа включают в себя две операции:

Первая — увеличение веса узлов дерева. Вначале увеличиваем вес листа, соответствующего считанному символу, на единицу. Затем увеличиваем вес родителя, чтобы привести его в соответствие с новыми значениями веса потомков. Этот процесс продолжается до тех пор, пока мы не доберемся до корня дерева. Среднее число операций увеличения веса равно среднему количеству битов, необходимых для того, чтобы закодировать символ.

Вторая операция — перестановка узлов дерева — требуется тогда, когда увеличение веса узла приводит к нарушению свойства упорядоченности, то есть тогда, когда увеличенный вес узла стал больше, чем вес следующего по порядку узла. Если и дальше продолжать обрабатывать увеличение веса, двигаясь к корню дерева, то дерево перестанет быть деревом Хаффмана.

Чтобы сохранить упорядоченность дерева кодирования, алгоритм работает следующим образом. Пусть новый увеличенный вес узла равен W+1. Тогда начинаем двигаться по списку в сторону увеличения веса, пока не найдем последний узел с весом W. Переставим текущий и найденный узлы между собой в списке, восстанавливая таким образом порядок в дереве (при этом родители каждого из узлов тоже изменятся). На этом операция перестановки заканчивается.

После перестановки операция увеличения веса узлов продолжается дальше. Следующий узел, вес которого будет увеличен алгоритмом, — это новый родитель узла, увеличение веса которого вызвало перестановку.

== Канонические коды Хаффмана ==
Проблема обычного алгоритма сжатия по Хаффману — недетерминированность. Для похожих последовательностей могут получиться разные деревья, так и одно дерево без правильной сериализации может соответствовать разным последовательностям. Для избежания применяют канонические коды Хаффмана.

В этом алгоритме не строится дерево Хаффмана<ref>Подробнее с примерами алгоритм расписан в Managing Gigabytes авторов Witten, Мoffat, Bell на 68-й странице.</ref>.

Состоит из двух этапов:
{|
|
# Подсчёт длины кода для какого-то символа
# Составление кода.
|}

=== Подсчёт длины ===
{|
|
# Посчитаем частотность для каждого символа
# Отсортируем их в лексикографическом порядке.
# В массив запишем частотность каждой буквы.
# Слева приписываем массив той же длины, но с порядковыми номерами из правого массива. Левый массив получается списком указателей на элементы правой части.
# В левой части делаем не [[Двоичная куча|возрастающую пирамиду]]. Но heap будет не по значению элементов массива, а по значению на ссылаемый элемент массива.
# Самый левый элемент указывает на символ из правого массива с наименьшей частотностью. Его можно удалить следующим образом:
## Правую половину не трогаем
## Первый элемент массива заменяем на самый правый элемент левого массива, якобы сдвигая границу разделения.
## Проверяем условия правильности пирамиды, если что-то не так, то надо повторить «хипизацию».
## Убирается первый элемент левой части массива и объединяется ранее убранным. Сумма их частотностей записывается в границу между левым и правым массивом.
## На место удалённого элемента в левой части записывается индекс массива куда добавили сумму частотностей на прошлом шаге.
## Из-за того объединили два элемента нужно изменить значения этих элементов массива ссылкой на родителя, куда их положили.
# Повторяем, в куче слева не останется 1 элемент.
# В правой части массива получились ссылки на элементы, объеднияющие 2 символа. Поэтому идём по массиву по ссылкам, инкрементируя уровень погружения.
# Количество переходов по ссылкам будет длиной кода Хаффмана.
|}

=== Составление кода ===
{|
|
# Расположим элементы в лексикографическом порядке.
# Составим таблицу, состоящую из блоков, начиная с самой большой длины кода. Каждый блок будет содержать элементы с одинаковой длиной кода.
# Самый первый символ таблицы кодируется нулями.
# В каждом блоке символы будут находиться в лексикографическом порядке.
# Коды в блоке будут иметь двоичный вид и различаться на 1.
# При переходе в следующий блок биты кода самого последнего символа отсекаются и добавляется 1.
|}

== Биграммная модель ==
Существует разновидность алгоритма Хаффмана, использующая контекст. В данном случае размер контекста равен единице (биграммный — два символа, триграммный — три и так далее). Это метод построения префиксного кода для моделей высших порядков, уже не источника без памяти. Он использует результат (предыдущей операции) операции над предыдущей буквой совместно с текущей буквой. Строится на основе [[Цепь Маркова|цепи Маркова]] с глубиной зависимости <math>r = 1</math>.<ref>{{Cite web|url = http://u.cs.biu.ac.il/~tomi/Postscripts/MathComp.pdf|title = Huffman Coding with Non-Sorted Frequencies|author = Shmuel T. Klein and Dana Shapira|work = |date = 2008|publisher = |access-date = 2016-01-02|archive-date = 2016-03-04|archive-url = https://web.archive.org/web/20160304110027/http://u.cs.biu.ac.il/~tomi/Postscripts/MathComp.pdf|deadlink = no}}</ref>

'''Алгоритм'''
# Строится таблица в виде квадрата — распределение вероятностей на биграммах. Сразу вычисляется стартовая схема, с помощью которой будет кодироваться только первая буква. Строками в таблице, например, являются предыдущие буквы, а столбцами текущие.
# Вычисляются вероятности для кодовых деревьев для контекстов.
# По контекстам длины <math>r = 1</math> строятся остальные кодовые деревья, с помощью которых будут кодироваться все остальные символы (кроме первого).
# Выполняется кодирование, первый символ кодируется согласно стартовой схеме, все последующие — исходя из кодовых деревьев для контекстов (предыдущего символа).
Декодирование выполняется аналогично: из стартовой кодовой схемы получаем первый контекст, а затем переходим к соответствующему кодовому дереву. Более того, декодеру необходима таблица распределения вероятностей.

'''Пример'''

Допустим, сообщение, которое надо закодировать '''«abcabcabc»'''. Нам заранее известна таблица частотностей символов (на основе других данных, например, статистических данных по словарю).
{| class="wikitable" style="text-align:center"
!
!''a''
!''b''
!''c''
!Сумма
|-
!''a''
|<math>\tfrac{3}{16}</math>
|<math>\tfrac{1}{16}</math>
|<math>\tfrac{1}{16}</math>
|<math>\tfrac{5}{16}</math>
|-
!''b''
|<math>\tfrac{1}{8}</math>
|<math>\tfrac{1}{16}</math>
|<math>\tfrac{1}{8}</math>
|<math>\tfrac{5}{16}</math>
|-
!''c''
|<math>\tfrac{1}{8}</math>
|<math>\tfrac{1}{8}</math>
|<math>\tfrac{1}{8}</math>
|<math>\tfrac{6}{16}</math>
|}
Имеем стартовую схему: <math>(a = \tfrac{5}{16}, b = \tfrac{5}{16}, c = \tfrac{6}{16})</math>. Сортируем по убыванию: <math>(c = \tfrac{6}{16}, a = \tfrac{5}{16}, b = \tfrac{5}{16})</math> и строим кодовое дерево Хаффмана.

Для контекста «'''a'''» имеем:
* <math>p(a / a) = p(a, a) / p(a) = \tfrac{3}{16} \div \tfrac{5}{16} = \tfrac{3}{5}</math>,
* <math>p(b / a) = p(b, a) / p(a) = \tfrac{1}{16} \div \tfrac{5}{16} = \tfrac{1}{5}</math>,
* <math>p(c / a) = p(c, a) / p(a) = \tfrac{1}{16} \div \tfrac{5}{16} = \tfrac{1}{5}</math>.
Для контекста «'''b'''» имеем:
* <math>p(a / b) = p(a, b) / p(b) = \tfrac{1}{8} \div \tfrac{5}{16} = \tfrac{2}{5}</math>,
* <math>p(b / b) = p(b, b) / p(b) = \tfrac{1}{16} \div \tfrac{5}{16} = \tfrac{1}{5}</math>,
* <math>p(c / b) = p(c, b) / p(b) = \tfrac{1}{8} \div \tfrac{5}{16} = \tfrac{2}{5}</math>.
Для контекста «'''c'''» имеем:
* <math>p(a / c) = p(a, c) / p(c) = \tfrac{1}{8} \div \tfrac{6}{16} = \tfrac{1}{3}</math>,
* <math>p(b / c) = p(b, c) / p(c) = \tfrac{1}{8} \div \tfrac{6}{16} = \tfrac{1}{3}</math>,
* <math>p(c / c) = p(c, c) / p(c) = \tfrac{1}{8} \div \tfrac{6}{16} = \tfrac{1}{3}</math>.
''Примечание: здесь '''p(x, y)''' не равно '''p(y, x)'''.''

Строим кодовые деревья для каждого контекста. Выполняем кодирование и имеем закодированное сообщение: (00, 10, 01, 11, 10, 01, 11, 10, 01).
* 00 — из кода буквы '''«a»''' для стартовой схемы,
* 10 — из кода буквы '''«b»''' для контекста '''«a»''',
* 01 — из кода буквы '''«c»''' для контекста '''«b»''',
* 11 — из кода буквы '''«a»''' для контекста '''«c»'''.

== Переполнение ==
В процессе работы алгоритма сжатия вес узлов в дереве кодирования Хаффмана неуклонно растет. Первая проблема возникает тогда, когда вес корня дерева начинает превосходить вместимость ячейки, в которой он хранится. Как правило, это 16-битовое значение и, следовательно, не может быть больше, чем 65535. Вторая проблема, заслуживающая ещё большего внимания, может возникнуть значительно раньше, когда размер самого длинного кода Хаффмана превосходит вместимость ячейки, которая используется для того, чтобы передать его в выходной поток. Декодеру все равно, какой длины код он декодирует, поскольку он движется сверху вниз по дереву кодирования, выбирая из входного потока по одному биту. Кодер же должен начинать от листа дерева и двигаться вверх к корню, собирая биты, которые нужно передать. Обычно это происходит с переменной типа «целое», и, когда длина кода Хаффмана превосходит размер типа «целое» в битах, наступает переполнение.

Можно доказать, что максимальную длину код Хаффмана для сообщений с одним и тем же входным алфавитом будет иметь, если частотности символов образует [[последовательность Фибоначчи]]. Сообщение с частотностями символов, равными числам Фибоначчи до Fib (18), — это отличный способ протестировать работу программы сжатия по Хаффману.

== Масштабирование весов узлов дерева Хаффмана ==
Принимая во внимание сказанное выше, алгоритм обновления дерева Хаффмана должен быть изменен следующим образом: при увеличении веса нужно проверять его на достижение допустимого максимума. Если мы достигли максимума, то необходимо «масштабировать» вес, обычно разделив вес листьев на целое число, например, 2, а потом пересчитав вес всех остальных узлов.

Однако при делении веса пополам возникает проблема, связанная с тем, что после выполнения этой операции дерево может изменить свою форму. Объясняется это тем, что при делении целых чисел отбрасывается дробная часть.

Правильно организованное дерево Хаффмана после масштабирования может иметь форму, значительно отличающуюся от исходной. Это происходит потому, что масштабирование приводит к потере точности статистики. Но со сбором новой статистики последствия этих «ошибок» практически сходят на нет. Масштабирование веса — довольно дорогостоящая операция, так как она приводит к необходимости заново строить все дерево кодирования. Но, так как необходимость в ней возникает относительно редко, то с этим можно смириться.

=== Выигрыш от масштабирования ===
Масштабирование веса узлов дерева через определенные интервалы дает неожиданный результат. Несмотря на то, что при масштабировании происходит потеря точности статистики, тесты показывают, что оно приводит к лучшим показателям сжатия, чем если бы масштабирование откладывалось. Это можно объяснить тем, что текущие символы сжимаемого потока больше «похожи» на своих близких предшественников, чем на тех, которые встречались намного раньше. Масштабирование приводит к уменьшению влияния «давних» символов на статистику и к увеличению влияния на неё «недавних» символов. Это очень сложно измерить количественно, но, в принципе, масштабирование оказывает положительное влияние на степень сжатия информации. Эксперименты с масштабированием в различных точках процесса сжатия показывают, что степень сжатия сильно зависит от момента масштабирования веса, но не существует правила выбора оптимального момента масштабирования для программы, ориентированной на сжатие любых типов информации.

== Применение ==
Кодирование Хаффмана широко применяется при сжатии данных, в том числе при сжатии фото- и видеоизображений ([[JPEG]], [[MPEG]]), в популярных архиваторах ([[PKZIP]], [[LZH]] и др.), в протоколах передачи данных HTTP ([[Deflate]]), MNP5 и MNP7 и других.

== Модификации ==
В 2013 году была предложена модификация алгоритма Хаффмана, позволяющая кодировать символы дробным количеством бит — ANS<ref>{{Cite web |url=http://chaos.if.uj.edu.pl/ZOA/files/semianria/chaos/28.04.2014.pdf |title=Архивированная копия |access-date=2016-01-02 |archive-date=2016-03-05 |archive-url=https://web.archive.org/web/20160305212234/http://chaos.if.uj.edu.pl/ZOA/files/semianria/chaos/28.04.2014.pdf |deadlink=no }}</ref><ref>{{Cite web |url=http://arxiv.org/pdf/1311.2540.pdf |title=Архивированная копия |access-date=2016-01-02 |archive-date=2016-09-11 |archive-url=https://web.archive.org/web/20160911213547/http://arxiv.org/pdf/1311.2540.pdf |deadlink=no }}</ref>. На базе данной модификации реализованы алгоритмы сжатия [[Zstandard]] (Zstd, Facebook, 2015—2016)<ref>[http://www.opennet.ru/opennews/art.shtml?num=45058 Facebook опубликовал реализацию алгоритма сжатия Zstandard 1.0] {{Wayback|url=http://www.opennet.ru/opennews/art.shtml?num=45058 |date=20160902142935 }} / Opennet.ru, 01.09.2016</ref> и {{нп5|LZFSE|LZFSE|fr|LZFSE}} (Apple, OS X 10.11, iOS 9, 2016)<ref>[https://www.opennet.ru/opennews/art.shtml?num=44746 Компания Apple открыла реализацию алгоритма сжатия без потерь LZFSE] {{Wayback|url=https://www.opennet.ru/opennews/art.shtml?num=44746 |date=20160911053312 }} / Opennet.ru, 07.07.2016</ref><ref>{{Cite web |url=https://www.infoq.com/news/2016/07/apple-lzfse-lossless-opensource |title=Apple Open-Sources its New Compression Algorithm LZFSE<!-- Заголовок добавлен ботом --> |access-date=2016-09-01 |archive-date=2016-09-11 |archive-url=https://web.archive.org/web/20160911215307/https://www.infoq.com/news/2016/07/apple-lzfse-lossless-opensource |deadlink=no }}</ref><ref>[https://developer.apple.com/library/mac/documentation/Performance/Reference/Compression/ Data Compression<!-- Заголовок добавлен ботом -->]</ref><ref>{{Cite web |url=https://github.com/lzfse/lzfse |title=GitHub — lzfse/lzfse: LZFSE compression library and command line tool<!-- Заголовок добавлен ботом --> |access-date=2016-09-01 |archive-date=2020-11-28 |archive-url=https://web.archive.org/web/20201128185751/https://github.com/lzfse/lzfse |deadlink=no }}</ref>.

== Примечания ==
{{примечания}}

== Литература ==
* {{книга
|автор = Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн.
|заглавие = Алгоритмы: построение и анализ
|оригинал = Introduction to Algorithms
|ссылка = 
|издание = 2-е изд
|место = {{М.}} |издательство = [[Вильямс (издательство)|Вильямс]]
|год = 2006
|страниц = 1296
|isbn = 0-07-013151-1
}}
* {{книга
|заглавие = Сжатие данных, изображения и звука
|автор = Д. Сэломон.
|isbn = 5-94836-027-X
|страниц = 368
|год = 2004
|место = {{М.}} |издательство = Техносфера
|тираж = 3000
}}
* {{книга
|заглавие = Managing Gigabytes: Compressing and Indexing Documents and Images
|автор = Ian H. Witten, Alistair Moffat, Timothy C. Bell
|isbn = 1558605703
|страниц = 551
|год = 1999
|Издательство = Morgan Kaufmann
|тираж =  
}}
* {{source|Q21694522|part=Глава 9. Жадные методы: Алгоритм Хаффмана|pages=392—398}}

* {{книга | автор = [[Марков, Александр Александрович (математик)|Марков А. А.]] | заглавие = Введение в теорию кодирования
 | место = М. | издательство  = Наука | год = 1982 | страниц = 192 | isbn = | ref = Марков}}

== Ссылки ==
* [http://www.webcenter.ru/~xander/HuffmanCode/huffcode.html Код Хаффмана] ([http://web.archive.org/web/20070927224229/http://www.webcenter.ru/~xander/HuffmanCode/huffcode.html WebArchive])
* [https://web.archive.org/web/20060613060343/http://rain.ifmo.ru/cat/view.php/vis/data-compression/huffman-tree-2001 Визуализатор построения дерева для m<sub>2</sub>=2]
* [https://web.archive.org/web/20060706115543/http://rain.ifmo.ru/cat/view.php/vis/data-compression/huffman-tree-2003 Визуализатор кодирования букв русского алфавита]
* [http://algolist.manual.ru/compress/standard/huffman.php Сжатие по алгоритму Хаффмана] на algolist.manual.ru
* [https://habrahabr.ru/post/144200/ Хабрахабр: Алгоритм Хаффмана на пальцах]
* [https://habrahabr.ru/post/132289/ Хабрахабр: Алгоритмы используемые при сжатии данных]
* [https://habrahabr.ru/post/142242/ Хабрахабр: Сжатие информации без потерь. Часть первая]

{{методы сжатия}}

[[Категория:Теория кодирования]]
[[Категория:Сжатие данных]]
[[Категория:Алгоритмы сжатия без потерь]]
[[Категория:Задачи, решаемые жадным алгоритмом]]